a = [3, 1, 2]
a.sort() #изменяет список
print(*a)

b = sorted(a) #создает отсортированную копию списка, исп-ся когда исходную последовательность нужно сохранить. возвращает всегда список
print(*b)

b = sorted(range(1, 10))
b = sorted('cba')

b = sorted(a, reverse = True) #в обратном порядке

print((1, 2) < (3, 4)) #сравнение поэлементное

# Рассмотрим такой пример: необходимо упорядочить введённые строки по длине, а в случае равной длины оставить их в том порядке,
# как они шли во входном файле. Например, для входных строк ''c'', ''abb'', ''b'' правильным ответом
# должно быть ''c'', ''b'', ''abb'' (''c'' идет раньше ''b'', т.к. они имеют равную длину,
# а ''c'' стояло во входных данных раньше ''b'').
#
# К счастью, сортировка, используемая в Питоне обладает свойством устойчивости (stable), т.е. для элементов с равным ключом сохраняется их взаимный порядок.

n = int(input())
strings = []
for i in range(n):
    strings.append(input())
print('\n'.join(sorted(strings, key=len)))

# В качестве еще одного примера рассмотрим задачу о сортировке точек на плоскости, заданных парой целых координат x и y
# по неубыванию расстояния от начала координат. В данном случае в качестве функции для генерации ключа,
# по которому будут сравниваться элементы, мы напишем свою функцию, которая будет возвращать квадрат расстояния от точки
# до начала координат. Квадрат расстояния мы используем для того,
# чтобы оставаться в целых числах и избавится от необходимости считать квадратный корень (медленно и неточно):

def dist(point):
    return point[0] ** 2 + point[1] ** 2

n = int(input())
points = []
for i in range(n):
    point = tuple(map(int, input().split()))
    points.append(point)
points.sort(key=dist)
for point in points:
    print(' '.join(map(str, point)))
