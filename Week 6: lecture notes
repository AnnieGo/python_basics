a = [3, 1, 2]
a.sort() #изменяет список
print(*a)

b = sorted(a) #создает отсортированную копию списка, исп-ся когда исходную последовательность нужно сохранить. возвращает всегда список
print(*b)

b = sorted(range(1, 10))
b = sorted('cba')

b = sorted(a, reverse = True) #в обратном порядке

print((1, 2) < (3, 4)) #сравнение поэлементное

# Рассмотрим такой пример: необходимо упорядочить введённые строки по длине, а в случае равной длины оставить их в том порядке,
# как они шли во входном файле. Например, для входных строк ''c'', ''abb'', ''b'' правильным ответом
# должно быть ''c'', ''b'', ''abb'' (''c'' идет раньше ''b'', т.к. они имеют равную длину,
# а ''c'' стояло во входных данных раньше ''b'').
#
# К счастью, сортировка, используемая в Питоне обладает свойством устойчивости (stable), т.е. для элементов с равным ключом сохраняется их взаимный порядок.

n = int(input())
strings = []
for i in range(n):
    strings.append(input())
print('\n'.join(sorted(strings, key=len)))

# В качестве еще одного примера рассмотрим задачу о сортировке точек на плоскости, заданных парой целых координат x и y
# по неубыванию расстояния от начала координат. В данном случае в качестве функции для генерации ключа,
# по которому будут сравниваться элементы, мы напишем свою функцию, которая будет возвращать квадрат расстояния от точки
# до начала координат. Квадрат расстояния мы используем для того,
# чтобы оставаться в целых числах и избавится от необходимости считать квадратный корень (медленно и неточно):

def dist(point):
    return point[0] ** 2 + point[1] ** 2

n = int(input())
points = []
for i in range(n):
    point = tuple(map(int, input().split()))
    points.append(point)
points.sort(key=dist)
for point in points:
    print(' '.join(map(str, point)))


# В чистом виде типа данных "структура" в стандарте языка Питон нет.
# Есть несколько способов реализации аналога структур: namedtuple из библиотеки collections,
# использование словарей (будет рассмотрено в следующих лекциях) или использование классов в качестве структур.
# Рассмотрим на примере последний способ.
#
# Напомним условие задачи: людей нужно упорядочить по убыванию роста, но в случае одинакового роста они должны
# быть упорядочены по фамилии. Решение с использованием классов в качестве структур будет выглядеть так:
class Man:
    height = 0
    name = ''

def manKey(man):
    return (-man.height, man.name)

n = int(input())
peopleList = []
for i in range(n):
    tempManData = input().split()
    man = Man()
    man.height = int(tempManData[0])
    man.name = tempManData[1]
    peopleList.append(man)
peopleList.sort(key=manKey)
for man in peopleList:
    print(man.height, man.name)

# Лямбда-функции
# В ряде случаев функции, используемые для получения ключа сортировки, так просты,
# что не хочется оформлять их стандартным образом, а хочется написать их прямо на месте
# и даже не давать им имени.
#
# Это можно осуществить с помощью лямбда-функций, которые могут заменить собой функции,
# содержащие в своем теле только оператор return. Запись лямбда-функции,
# возводящей число в квадрат может выглядеть так:

lambda x: x**2

# Что эквивалентно привычной записи функции:

def sqr(x):
    return x**2

# с помощью лямбда-функции мы можем вывести список квадратов всех чисел от 1 до 100 всего
# в одну строку:
print(' '.join(map(lambda x: str(x**2), range(1, 101))))

# Вернемся к задаче сортировки точек по удаленности от начала координат.
# Эта задача также может быть решена с использованием лямбда-функции:

n = int(input())
points = []
for i in range(n):
    point = tuple(map(int, input().split()))
    points.append(point)
points.sort(key=lambda point: point[0]**2 + point[1]**2)
for point in points:
    print(' '.join(map(str, point)))

# Лямбда-функция может принимать несколько параметров (тогда после слова lambda
# нужно записать их имена через запятую), однако при использовании их в sort или
# map обычно применяется один параметр.
#
# В языке Питон функция также является объектом и мы можем создать ссылку на объект
# типа функция. Например, две записи функции возведения в квадрат эквивалентны:

def traditionalSqr(x):
    return x**2

lambdaSqr = lambda x: x**2
print(traditionalSqr(3))
print(lambdaSqr(3))


x = [1, 5, 2, 3]
y = list(map(lambda x: x**2, x))
print(*y)

# Сейчас мы научимся создавать функции, которые принимают именованные параметры.
# Например, напишем функцию, печатающую что угодно итерируемое, состоящее из чего
# угодно приводимого к строке, с именованным параметром sep, по-умолчанию равным пробелу:
def printList(myList, sep=' '):
    print(sep.join(map(str, myList)))

printList([1, 2, 3])
printList([3, 2, 1], sep='\n')

# Именованный параметр в объявлении функции должен идти после основных параметров.
# В списке параметров записывается его имя, а затем значение по-умолчанию
# (т.е. то значение, которое будет подставляться на место соответствующего параметра,
# если он не был передан при вызове функции).

# Также мы пользовались функциями, которые умеют принимать произвольное количество
# параметров. Например, в функцию print можно передать любое количество параметров.
# Можно написать собственные функции, которые будут принимать произвольное количество
# параметров. При этом параметры функции будут упакованы в список.
# Например, функция подсчета суммы всех переданных параметров может выглядеть так:

def mySum(*args):
    nowSum = 0
    for now in args:
        nowSum += now
    return nowSum

print(mySum(1, 2))
print(mySum(1, 2, 3, 4))

# Функция принимает один параметр, перед которым написана звездочка - это признак того,
# что аргументы будут упакованы в список.
#
# Можно писать функции, которые принимают не менее определенного количества параметров.
# Например, мы можем написать функцию поиска минимума среди неопределенного
# числа аргументов, но в нее должно быть передано не менее одного аргумента:
def myMin(first, *others):
    nowMin = first
    for now in others:
        if now < nowMin:
            nowMin = now
    return nowMin

print(myMin(1))
print(myMin(3, 1, 2))

# Во многих задачах заранее неизвестно, сколько данных нам предстоит считать.
# Особенно яркий пример - это обработка текста, когда мы заранее не знаем, сколько строк нам будет введено.
#
# Наиболее удобно работать с такими данными не пользуясь функцией input,
# используя методы чтения файла (или ввода с консоли) целиком или построчно.
#
# Рассмотрим простой пример: считать все строки файла input.txt
# и вывести каждую строку развернутой в файл output.txt:
inFile = open('input.txt', 'r', encoding='utf8')
outFile = open('output.txt', 'w', encoding='utf8')
lines = inFile.readlines()
for line in lines:
    print(line[-2::-1], file=outFile)
inFile.close()
outFile.close()

# Для открытия файла используется функция open, принимающая два параметра:
# имя файла и режим открытия (''r'' для чтения и ''w'' для записи),
# а также именованный параметр encoding (значение кодировки ''utf8''
# подходит для большинства современных текстовых файлов).
# Эта функция возвращает ссылку на объект типа файл.
#
# Для чтения всех строк из файла используется метод readlines, который возвращает список всех строк
# (в смысле lines) файла. Обратите внимание, что строки попадают в список вместе с символом перевода строки,
# в нашей программе это учитывается при создании среза (этот символ последний в строке).
# В тестирующей системе все входные файлы имеют перенос строки после последней строки,
# в реальной жизни это может оказаться не так и тогда программа будет работать неверно.
#
# Для печати в файл мы пользуемся стандартной функцией print, которой передается
# именованный параметр file с указанием, в какой файл печатать.
#
# После окончания работы с файлами нужно вызвать для них методы close.
#
# В этой задаче, на самом деле, можно было обойтись без запоминания всего файла в памяти
# (это особенно актуально для больших файлов).
# Решение без запоминания всего файла можно было реализовать так:
inFile = open('input.txt', 'r', encoding='utf8')
outFile = open('output.txt', 'w', encoding='utf8')
for line in inFile:
    print(line[-2::-1], file=outFile)
inFile.close()
outFile.close()

# Переменные типа файл являются iterable и умеют возвращать очередную строку из файла, не храня его целиком в памяти.
#
# Также существует метод read, который позволяет считать все содержимое файла в одну строковую переменную
# (при этом содержащую в себе переводы строки \n).
#
# В принципе, читать до конца ввода можно и из консоли.
# Для этого нужно подключить библиотеку sys и использовать определенный в ней файловый дескриптор stdin в качестве файла
# (например, для перебора строк консоли можно написать for line in sys.stdin).
# Ввести признак конца файла в консоли можно, нажав Ctrl+Z в Windows или Ctrl+D в Unix-системах.
# В среде программирования такой способ может не работать.
# Более подробно в этой теме: https://www.coursera.org/learn/python-osnovy-programmirovaniya/discussions/all/threads/DLrJXKbWEeiD2QqOJunOiA/replies/fJUPEK4gEeix7A7XXq2u1g.
#
#  Еще об одном способе работы с файлами с помощью конструкции with .. as ..,
#  что позволяет автоматически вызывать метод close(),
#  можно почитать здесь: http://book.pythontips.com/en/latest/open_function.html.

# В ряде задач возможные значения в сортируемом списке сильно ограничены.
# Например, если мы хотим отсортировать оценки от 0 до 10, то может оказаться эффективнее подсчитать,
# сколько раз встречалась каждая из оценок и затем вывести её столько раз.
#
# Реализация такого подхода очень проста:

marks = map(int, input().split())
cntMarks = [0] * 11
for mark in marks:
    cntMarks[mark] += 1
for nowMark in range(11):
    print((str(nowMark) + ' ') * cntMarks[nowMark], end='')

# В этой программе мы создали список, состоящий из 11 нулей в одну строку. Этот приём часто пригождается и в других задачах.

# Связь задач поиска и сортировки
# Во многих задачах линейного поиска (например, поиск минимального элемента) возникает соблазн воспользоваться сортировкой.
#
# С этим соблазном следует бороться, т.к. сложность сортировки в языке Питон составляет O(NlogN),
# т.е. для сортировки списка из N элементов нужно совершить порядка NlogN действий.
#
# При этом алгоритмы линейного поиска работают за O(N), что асимптотически быстрее, чем сортировка.
# Поэтому в задачах линейного поиска (даже для поиска третьего по величине элемента)
# следует реализовывать линейный поиск, а не пользоваться сортировкой.
#
# По иронии судьбы, сортировка в интерпретаторе CPython может оказаться быстрее рукописного
# линейного поиска (из-за того, что она реализовано максимально эффективно и на языке Си).
# Но это досадное недоразумение не должно побороть в вас желание писать линейный поиск руками.
