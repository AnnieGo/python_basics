# Кортеж может состоять из элементов произвольных типов и является неизменяемым типом,
# т.е. нельзя менять отдельные элементы кортежа, как и символы строки.
# Константные кортежи можно создавать в программе, записывая элементы через запятую и окружая скобками.
# Например, testTuple = (1, 2, 3).
# В случае, если кортеж является единственным выражением слева или справа от знака присваивания,
# то скобки могут быть опущены.

# В одном кортеже могут храниться элементы различных типов, например, строки, числа и другие кортежи вперемешку.
# Например, в кортеже myTuple = (('a', 1, 3.14), 'abc', ((1), (2, ))), myTuple[0] будет кортежем ('a', 1, 3.14),
# myTuple[1] строкой 'abc', а myTuple[2] кортежем состоящим из числа 1 и кортежа из одного элемента (2, ).
# Числа, записанные в скобках, интерпретируются как числа, в случае возникновения необходимости создать кортеж
# из одного элемента необходимо после значения элемента написать запятую. Если вывести myTuple[2][1],
# то напечатается (2,), а если вывести myTuple[2][1][0], то будет напечатано число 2.
#
# Кортеж, содержащий в себе один элемент, называется синглтоном.

#Распаковкой называется процесс присваивания, в котором кортеж, составленный из отдельных переменных
# находится в левой части выражения. В таком выражении справа должен находится кортеж той же длины.
# Например, в результате выполнения такого кода:
manDesc = ("Ivan", "Ivanov", 28)
name, surname, age = manDesc

# Функция range
# В языке Питон есть функция range, которая позволяет генерировать объекты типа iterable
# (к элементам которых можно получать последовательный доступ), состоящие из целых чисел.

a, b, c = 1, 2, 3
a, b, c = c, b, a
print(a, b, c) #функции print передается в качестве параметра не кортеж, а три целых числа.

#Для вывода объектов типа iterable мы будем пользоваться функцией tuple, которая позволяет сделать кортеж,
# состоящий из всех элементов iterable, записанных последовательно.
print(tuple(range(10)))

# Также существует range с тремя параметрами range(from, to, step), который сгенерирует iterable с числами от from,
# не превышающие to с шагом изменения step. Если шаг отрицателен, то from должен быть больше to. Например, range(10, 0, -2)
# сгенерирует последовательность чисел 10, 8, 6, 4, 2. 0 не будет входить в эту последовательность.

# Цикл for
# Цикл for позволяет поочередно перебрать элементы из чего-нибудь итерируемого (iterable или tuple).
# Например, мы можем перебрать названия цветов яблок таким способом:
for color in ('red', 'green', 'yellow'):
    print(color, 'apple')

# Например, с помощью for можно напечатать нечетные числа от 1 до 100:
for i in range(1, 100, 2):
    print(i, end = ' ')

# в обратном порядке
for i in range(10, -1, -1):
    print(i, end = ' ')

# Внутри for может быть расположен и другой for. Вот так выглядит код для вывода таблицы умножения всех чисел от 1 до 10 (не очень красивой):
for i in range(1, 11):
    for j in range(1, 11):
        print(i * j, end=' ')
    print()

#СПИСКИ
# Главным отличием списка от кортежа является изменяемость.
# То есть можно взять определенный элемент списка и изменить его (он может быть в левой части операции присваивания).
myList = [1, 2, 3]
myList[1] = 4
print(myList)

# Изменение списков
# Список, как и другие типы в языке Питон, является ссылкой на список ссылок.
# При этом список является изменяемым объектом, т. е. содержимое по этой ссылке может поменяться.
# Рассмотрим такой пример:
a = [1, 2]
b = a
b[0] = 3
print(a)

#Если списки переданы в функцию в качестве параметров, то их содержимое также может быть изменено этой функцией:
def replaceFirst(myList):
    myList[0] = 'x'

nowList = list('abcdef')
replaceFirst(nowList)
print(nowList)

# Однако, сама ссылка внутри функции не может быть изменена, если она передана как параметр функции. Рассмотрим пример:
def reverseList(funcList):
    funcList = funcList[::-1]

mainList = list('abc')
reverseList(mainList)
print(mainList)

#Эта программа не развернет список, т. е. вывод будет ['a', 'b', 'c'].

#Метод split позволяет разрезать строку (string) на отдельные слова ("токены").
# В качестве разделителя может выступать пробел, символ табуляции или перевода строки.
# Этот метод не изменяет строку и возвращает список строк-токенов.

print('red green        blue'.split())

#Чтобы научиться читать числа из одной строки нужно научиться еще одной функции - map.
# Функция map принимает два параметра: первый это функции, а второй - iterable элементов,
# к которому нужно применить эту функцию.
# В результате получается iterable с результатом применения функции к каждому элементу списка параметра.

print(list(map(len, ['red', 'green', 'blue']))) #напечатает [3, 5, 4] - список с результатом применения функции len к списку ['red', 'green', 'blue'].

numList = list(map(int, input().split()))

# Метод join позволяет объединить iterable строк, используя ту строку, к которой он применен, в качестве разделителя. Например, такой код:
print(', '.join(['Veni', 'Vidi', 'Vici']))

# выведет Veni, Vidi, Vici. Строка ', ' будет выступать в качестве разделителя который будет вставляться после каждой строки из списка-параметра (кроме последней).

# Метод join позволяет быстро и коротко выводить списки чисел. Проблема в том, что он умеет принимать в качестве параметра только iterable строк. 
Но с помощью функции map мы можем легко получить iterable из списка чисел, применив к каждому элементу функцию str. 
Вывод списка чисел numList разделенных пробелами будет выглядеть так:
numList = [1, 2, 3]
print(' '.join(map(str, numList)))

# Методы, не изменяющие список и возвращающие значение:
#
# count(x) - подсчитывает число вхождений значения x в список. Работает за время O(N)
#
# index(x) - находит позицию первого вхождения значения x в список. Работает за время O(N)
#
# index(x, from) - находит позицию первого вхождения значения x в список, начиная с позиции from.
# Работает за время O(N)
#
# Методы, не возвращающие значение, но изменяющие список:
#
# append(x) - добавляет значение x в конец списка
#
# extend(otherList) - добавляет все содержимое списка otherList в конец списка.
# В отличие от операции + изменяет объект к которому применен, а не создает новый
#
# remove(x) - удаляет первое вхождение числа x в список. Работает за время O(N)
#
# insert(index, x) - вставляет число x в список так, что оно оказывается на позиции index.
# Число, стоявшее на позиции index и все числа правее него сдвигаются на один вправо. Работает за время O(N)
#
# reverse() - Разворачивает список (меняет значение по ссылке, а не создает новый список как myList[::-1]).
# Работает за время O(N)
#
# Методы, возвращающие значение и изменяющие список:
#
# pop() - возвращает последний элемент списка и удаляет его
#
# pop(index) - возвращает элемент списка на позиции index и удаляет его. Работает за время O(N)

#необходимо выбрать все нечетные элементы списка myList и удалить их из него.
numbers = list(map(int, input().split()))
i = 0
while i < len(numbers):
    if numbers[i] % 2 != 0:
        numbers.pop(i)
    else:
        i += 1
print(' '.join(map(str, numbers)))

# Такое решение будет работать, но оно не очень эффективно. Каждый раз при удалении элемента нам придется совершать
# количество операций, пропорциональное длине списка. Итоговое количество операций
# в худшем случае будет пропорционально квадрату количества элементов в списке.
#
# В случае, если нет очень строгого ограничения в памяти, в задачах, где нужно удалить
# часть элементов списка гораздо проще создать новый список, в который нужно добавлять только подходящие элементы.

numbers = list(map(int, input().split()))
newList = []
for i in range(len(numbers)):
    if numbers[i] % 2 == 0:
        newList.append(numbers[i])
print(' '.join(map(str, newList)))

